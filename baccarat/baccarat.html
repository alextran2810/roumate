<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="manifest" href="manifest.json" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Baccarat Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>


  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: url("background.webp") no-repeat center center fixed;
      background-size: cover;
      /* make it fill the screen */
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 {
      text-align: center;
      margin: 20px 0;
    }

    #chart-container {
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 15px;
      box-sizing: border-box;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    #trackerChart {
      /* Slightly shorter height and fully responsive width */
      height: 400px !important;
      width: 100% !important;
    }

    #button-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: #fff;
      border-top: 1px solid #ddd;
      margin-top: 10px;
      border-radius: 0 0 10px 10px;
    }

    .top-row {
      position: fixed;
      left: 0;
      width: 100%;
      background: rgba(245, 245, 245, 0.95);
      backdrop-filter: blur(6px);
      border-top: 1px solid #ccc;
      display: flex;
      justify-content: center;
      gap: 12px;
      padding: 10px;
      z-index: 100;
    }

    .bottom-row {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(245, 245, 245, 0.95);
      /* semi-transparent */
      backdrop-filter: blur(6px);
      /* nice frosted effect */
      /* match page bg */
      border-top: 1px solid #ccc;
      display: flex;
      justify-content: center;
      gap: 12px;
      padding: 10px;
      z-index: 100;
      /* ensure above other elements */
    }


    button {
      flex: 1;
      border: none;
      border-radius: 8px;
      color: black;
      /* instead of white */
      cursor: pointer;
      font-size: 16px;
      touch-action: manipulation;
      padding: 14px 0;
      font-weight: bold;
      /* optional, makes text clearer */
    }

    /* Top row */
    #bankerBtn {
      background-color: #e74c3c;
    }

    /* red */
    #tieBtn {
      background-color: #2ecc71;
    }

    /* green */
    #playerBtn {
      background-color: #3498db;
    }

    /* blue */

    /* Bottom row */
    #resetBtn {
      background-color: yellowgreen;
    }

    /* dark green */
    #undoBtn {
      background-color: yellowgreen;
    }

    /* orange */
  </style>
</head>

<body>
  <h1>Baccarat Tracker</h1>
  <div id="chart-container">
    <canvas id="trackerChart"></canvas>
  </div>

  <div id="button-container">
    <div class="top-row">
      <button id="bankerBtn">Banker</button>
      <button id="tieBtn">Tie</button>
      <button id="playerBtn">Player</button>
    </div>
    <div id="extra-charts" style="display: flex; flex-wrap: wrap; gap: 20px; margin: 20px;">
  <div style="flex:1; min-width:250px; background:#fff; padding:10px; border-radius:10px;">
    <canvas id="pieChart"></canvas>
  </div>
  <div style="flex:1; min-width:250px; background:#fff; padding:10px; border-radius:10px;">
    <canvas id="streakChart"></canvas>
  </div>
</div>

    <div class="bottom-row">
      <button id="resetBtn">Reset</button>
      <button id="undoBtn">Undo</button>
    </div>
    
  </div>



  <script>
// Track counts
let bankerWins = 0, playerWins = 0, tieWins = 0;
let streaks = { banker: [], player: [] };
let currentStreak = { side: null, length: 0 };

// Pie Chart
const pieCtx = document.getElementById('pieChart').getContext('2d');
const pieChart = new Chart(pieCtx, {
  type: 'pie',
  data: {
    labels: ['Banker', 'Player', 'Tie'],
    datasets: [{
      data: [0,0,0],
      backgroundColor: ['#e74c3c','#3498db','#2ecc71']
    }]
  },
  options: { plugins: { legend: { position:'bottom' } } }
});

// Streak Histogram
const streakCtx = document.getElementById('streakChart').getContext('2d');
const streakChart = new Chart(streakCtx, {
  type: 'bar',
  data: {
    labels: ['1','2','3','4','5+'],
    datasets: [
      { label:'Banker Streaks', data:[0,0,0,0,0], backgroundColor:'#e74c3c' },
      { label:'Player Streaks', data:[0,0,0,0,0], backgroundColor:'#3498db' }
    ]
  },
  options: { responsive:true, plugins:{ legend:{ position:'bottom' } } }
});

// Update stats
function updateStats(winner) {
  if (winner==='banker') bankerWins++;
  if (winner==='player') playerWins++;
  if (winner==='tie') tieWins++;

  // Pie chart update
  pieChart.data.datasets[0].data = [bankerWins, playerWins, tieWins];
  pieChart.update('none');

  // Handle streaks
  if (winner==='tie') {
    // ties don't affect streaks
  } else {
    if (currentStreak.side === winner) {
      currentStreak.length++;
    } else {
      if (currentStreak.side) {
        pushStreak(currentStreak.side, currentStreak.length);
      }
      currentStreak.side = winner;
      currentStreak.length = 1;
    }
  }

  streakChart.update('none');
}

function pushStreak(side, len) {
  const bucket = Math.min(len, 5) - 1; // 1→index0 ... 5+→index4
  const ds = (side==='banker') ? streakChart.data.datasets[0] : streakChart.data.datasets[1];
  ds.data[bucket]++;
}

// Call updateStats when user presses buttons
document.getElementById('bankerBtn').addEventListener('click', () => {
  updateStats('banker');
});
document.getElementById('playerBtn').addEventListener('click', () => {
  updateStats('player');
});
document.getElementById('tieBtn').addEventListener('click', () => {
  updateStats('tie');
});




    let hoveredLabelKey = null;

    const labels = [0];
    const values = [0];
    const segmentColors = [];

    const ctx = document.getElementById('trackerChart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          data: values,
          borderWidth: 2,
          fill: false,
          pointBackgroundColor: ctx => {
            const i = ctx.dataIndex;
            if (i === 0) return 'gray';
            const prev = ctx.dataset.data[i - 1];
            const curr = ctx.dataset.data[i];
            if (curr > prev) return '#3498db';
            if (curr < prev) return '#e74c3c';
            else { return '#2ecc71'; }
          },
          pointBorderColor: ctx => {
            const i = ctx.dataIndex;
            if (i === 0) return 'gray';
            const prev = ctx.dataset.data[i - 1];
            const curr = ctx.dataset.data[i];
            if (curr > prev) return '#3498db';
            if (curr < prev) return '#e74c3c';
            else { return '#2ecc71'; }
          },


          pointRadius: 3,   // smaller dot size

          tension: 0.1,
          segment: {
            borderColor: ctx => {
              const index = ctx.p1DataIndex;
              return segmentColors[index - 1] || '#999';
            }
          },
          borderColor: '#000'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          annotation: { annotations: {} },
          legend: { display: false }
        },
        scales: {
          y: { beginAtZero: false }
        },
        onClick: (event, elements, chart) => {
          const annotations = chart.options.plugins.annotation.annotations;
          const rect = chart.canvas.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const clickY = event.clientY - rect.top;

          for (let key in annotations) {
            const ann = annotations[key];
            if (ann.type === 'line') {
              // --- check label first ---
              if (ann.label && ann.label.enabled) {
                const ctx = chart.ctx;
                ctx.font = "12px Arial";

                // anchor at xMin,yMin
                const x = chart.scales.x.getPixelForValue(ann.xMin);
                const y = chart.scales.y.getPixelForValue(ann.yMin);

                const textWidth = ctx.measureText(ann.label.content).width;
                const textHeight = 16;

                const box = {
                  left: x - 4,
                  right: x + textWidth + 4,
                  top: y - textHeight,
                  bottom: y
                };

                if (clickX >= box.left && clickX <= box.right && clickY >= box.top && clickY <= box.bottom) {
                  console.log("Deleting by label:", ann);
                  const newAnnotations = { ...annotations };
                  delete newAnnotations[key];
                  chart.options.plugins.annotation.annotations = newAnnotations;
                  chart.update();
                  return; // done
                }
              }

              // --- if not label, then check line distance ---
              const x1 = chart.scales.x.getPixelForValue(ann.xMin);
              const y1 = chart.scales.y.getPixelForValue(ann.yMin);
              const x2 = chart.scales.x.getPixelForValue(ann.xMax);
              const y2 = chart.scales.y.getPixelForValue(ann.yMax);

              const A = clickX - x1;
              const B = clickY - y1;
              const C = x2 - x1;
              const D = y2 - y1;
              const dot = A * C + B * D;
              const lenSq = C * C + D * D;
              let param = -1;
              if (lenSq !== 0) param = dot / lenSq;

              let xx, yy;
              if (param < 0) { xx = x1; yy = y1; }
              else if (param > 1) { xx = x2; yy = y2; }
              else { xx = x1 + param * C; yy = y1 + param * D; }

              const dx = clickX - xx;
              const dy = clickY - yy;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < 6) {
                console.log("Deleting by line:", ann);
                const newAnnotations = { ...annotations };
                delete newAnnotations[key];
                chart.options.plugins.annotation.annotations = newAnnotations;
                chart.update();
                return;
              }
            }
          }
        }
      }

    });
    chart.canvas.addEventListener("mousemove", (event) => {
      const annotations = chart.options.plugins.annotation.annotations;
      const ctx = chart.ctx;
      const rect = chart.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      hoveredLabelKey = null;

      for (let key in annotations) {
        const ann = annotations[key];
        if (ann.label && ann.label.enabled) {
          const x = chart.scales.x.getPixelForValue(ann.xMin);
          const y = chart.scales.y.getPixelForValue(ann.yMin);

          ctx.save();
          ctx.font = "12px Arial";
          const textWidth = ctx.measureText(ann.label.content).width;
          const textHeight = 16;
          const box = { left: x - 4, right: x + textWidth + 4, top: y - textHeight, bottom: y };

          if (mouseX >= box.left && mouseX <= box.right && mouseY >= box.top && mouseY <= box.bottom) {
            hoveredLabelKey = key;
            break;
          }
          ctx.restore();
        }
      }
      chart.canvas.style.cursor = hoveredLabelKey ? "pointer" : "default";

      chart.update(); // redraw so hover color applies
    });

    function findTrendlines(type = 'support') {
      const trendPoints = [];

      for (let i = 1; i < values.length - 1; i++) {
        const prev = values[i - 1];
        const curr = values[i];
        const next = values[i + 1];

        if (type === 'support' && curr <= prev && curr <= next && (curr < prev || curr < next)) {
          trendPoints.push({ index: i, value: curr });
        }
        if (type === 'resistance' && curr >= prev && curr >= next && (curr > prev || curr > next)) {
          trendPoints.push({ index: i, value: curr });
        }
      }

      const lines = [];
      const tolerance = 0.05;   // slope tolerance
      const extendBy = 5;

      if (trendPoints.length >= 3) {
        // Sort by index (time)
        trendPoints.sort((a, b) => a.index - b.index);

        for (let i = 0; i < trendPoints.length - 2; i++) {
          for (let j = i + 1; j < trendPoints.length - 1; j++) {
            for (let k = j + 1; k < trendPoints.length; k++) {
              const p1 = trendPoints[i];
              const p2 = trendPoints[j];
              const p3 = trendPoints[k];

              const slope1 = (p2.value - p1.value) / (p2.index - p1.index);
              const slope2 = (p3.value - p2.value) / (p3.index - p2.index);

              if (Math.abs(slope1 - slope2) < tolerance) {
                // Instead of pushing every line, we check if it can extend existing one
                const slope = (p3.value - p1.value) / (p3.index - p1.index);

                // If we already have a line with same slope (within tolerance)
                const existing = lines.find(l =>
                  Math.abs(((l.yMax - l.yMin) / (l.xMax - l.xMin)) - slope) < tolerance
                );

                if (existing) {
                  // Extend existing line if this one is longer
                  if ((p3.index - p1.index) > (existing.xMax - existing.xMin)) {
                    existing.xMax = p3.index + extendBy;
                    existing.yMax = p1.value + slope * (p3.index - p1.index + extendBy);
                  }
                } else {
                  // Otherwise, add as new
                  lines.push({
                    id: type + "_" + Date.now(),
                    type: 'line',
                    xMin: p1.index,
                    xMax: p3.index + extendBy,
                    yMin: p1.value,
                    yMax: p1.value + slope * (p3.index - p1.index + extendBy),
                    borderColor: type === 'support' ? 'black' : 'orange',
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                      display: true,   // always show
                      content: type === 'support' ? 'Support' : 'Resistance',
                      position: 'center',  // place in the middle of the line
                      backgroundColor: type === 'support' ? 'rgba(0,255,0,0.15)' : 'rgba(255,165,0,0.15)',
                      color: type === 'support' ? 'black' : 'orange',
                      font: {
                        weight: 'bold',
                        size: 12
                      },
                      rotation: 'auto'  // align label along the line
                    }
                  });

                }
              }
            }
          }
        }
      }

      return lines;
    }
    function detectSupportResistance() {
      const supportLines = findTrendlines('support');
      const resistanceLines = findTrendlines('resistance');

      // Keep only the last 3
      const latestSupports = supportLines.slice(-3);
      const latestResistances = resistanceLines.slice(-3);

      const annotations = {};
      let counter = 0;

      [...latestSupports, ...latestResistances].forEach(line => {
        annotations["line" + counter++] = line;
      });

      chart.options.plugins.annotation.annotations = annotations;
    }

    function updateChart(animation = true) {
      detectSupportResistance();
      chart.update(animation);
    }
    function saveHistory() {
      historyStack.push({
        labels: [...labels],
        values: [...values],
        segmentColors: [...segmentColors]
      });
      // Keep only last 10 actions to limit memory use
      if (historyStack.length > 10) {
        historyStack.shift();
      }
    }
    let historyStack = [];

    document.getElementById('bankerBtn').addEventListener('click', () => {
      saveHistory();
      const last = values[values.length - 1];
      values.push(last - 1);
      labels.push(values.length - 1);
      segmentColors.push("#e74c3c");
      updateChart();
    });


    document.getElementById('playerBtn').addEventListener('click', () => {
      saveHistory();
      const last = values[values.length - 1];
      values.push(last + 1);
      labels.push(values.length - 1);
      segmentColors.push("#3498db");
      updateChart();
    });

    document.getElementById('tieBtn').addEventListener('click', () => {
      saveHistory();
      const last = values[values.length - 1];
      values.push(last); // Tie does not change the score
      labels.push(values.length - 1);
      segmentColors.push("#2ecc71"); // green
      updateChart();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      saveHistory();
      labels.length = 0;
      values.length = 0;
      segmentColors.length = 0;
      labels.push(0);
      values.push(0);
      updateChart();
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (historyStack.length > 0) {
        const prev = historyStack.pop();
        labels.length = 0;
        labels.push(...prev.labels);
        values.length = 0;
        values.push(...prev.values);
        segmentColors.length = 0;
        segmentColors.push(...prev.segmentColors);
        updateChart('none');
      } else {
        alert("Nothing to undo.");
      }
    });

  </script>
</body>

</html>